# CS 3210 - Lab 1
Paras Jain (pjain67)

Questions
---------

   1) Assuming that the following JOS kernel code is correct, what type should
      variable x have, uintptr_t or physaddr_t?
      > mystery_t x;
      > char* value = return_a_pointer();
      > *value = 10;
      > x = (mystery_t) value;

      mystery_t is of type uintptr_t because value is a pointer which is a virtual
   	memory address. Physical memory addresses don't make sense as those are used by
   	the kernel and don't translate into (de)referenceable memory addresses.

   2) What entries (rows) in the page directory have been filled in at this point?
      What addresses do they map and where do they point? In other words, fill out
      this table as much as possible:

      Entry	   Base Virtual Address	      Points to (logically)
      =====================================================================================
      1023  	0xFFC00000	               Page table for top 4MB of phys memory
      1022  	0xFF800000	               Page table for the top-8MB - top-4MB] segment of RAM
      1021     0xFF400000                 Page table for the [top - 12MB, top - 8MB] of RAM
      ...
      961      0xF0400000                 Page table for the 4MB - 8MB segment of RAM
      960      0xF0000000                 Page table for the 0MB - 4MB segment of RAM
      959      0xEFC00000                 CPU0 kernel stack
      958      0xEF800000                 Kernel Stack
      957      0xEF400000                 Current Page Table
      956      0xEF000000                 User pages
      UTOP
      1        0x00400000                 Nothing
      0        0x00000000

   3) We have placed the kernel and user environment in the same address space. Why
      will user programs not be able to read or write the kernelâ€™s memory? What
      specific mechanisms protect the kernel memory?

      The kernel memory is above ULIM. User mode code cannot read/write into the
      kernel memory region. This allows the same address space to be shared.
      Permission bits set on the memory pages control access to memory so
      without user level permissions, user space code cannot use it. User code
      is CPL 3. Kernel code is CPL 0. This limits kernel code and device driver
      code to access protected code without PTE_U.

      The specific mechanism that enforces this is the MMU when it
      translates virtual addresses to physical addresses. If user mode code
      attempts to access.

   4) What is the maximum amount of physical memory that this operating system can
      support? Why?

      256MB. KERNBASE is 0xf000000. The page table grows up to 2^32. Therefore
      this is the max memory that the OS can support. While a much larger space
      of virtual memory is availible, only so much is availible for mapping the
      linear addresses to physical addresses.

   5) How much space overhead is there for managing memory, if we actually had the
      maximum amount of physical memory? How is this overhead broken down?

      There is ~4MB of overhead. There are 1024 pages. Each page uses 4KB 
      (4096b). This is 1024 * 4KB = 4MB. There is also a page directory which is
      1024 entries, each 32bits. This is 4,198,400 bytes total.

   6) Revisit the page table setup in kern/entry.S and kern/entrypgdir.c.
      Immediately after we turn on paging, EIP is still a low number (a little
      over 1MB). At what point do we transition to running at an EIP above
      KERNBASE? What makes it possible for us to continue executing at a low EIP
      between when we enable paging and when we begin running at an EIP above
      KERNBASE? Why is this transition necessary?

      The transition happens in entry.S at the jmp instruction:
      
      entry.S
      >   mov   $relocated, %eax
      >   jmp   *%eax
      >   ...

      It is OK to be running at a low EIP because we are using a simple pgdir
      that maps "VA's [0, 4MB) to PA's [0, 4MB)" in entrypgdir.c. This simple
      mapping allows execution to continue though the transition to execution
      after KERNBASE. It is OK to load this temporary transitional pgdir as
      kernel_pgdir is loaded later.



Challenge
----------   

   For the challenge, I chose to extend the JOS monitor.c program with several
   functions to probe into virtual address mappings. These programs were:
      - pageperm: sets/clears a permission bit on a page
      - showmappings: show a list of mappings and permssions over a VA range
      - dumpvirt: dumps a range of virtual memory addresses to the console
      - dumpphys: dumps a range of physical memory addresses to the console

   Each of these programs was straightforward - they read arguments from the
   terminal, use pgdir_walk to traverse to the correct page table entry and
   process the pte as necessary (printing the permissions or setting a
   permission bit). Dumping values to terminal did not require use of the page
   directory.

   My implementations of the four functions are in monitor.c and below:

      > int
      > mon_showmappings(int argc, char **argv, struct Trapframe *tf)
      > { 
      >   if (argc != 3) {
      >     cprintf("help: %s 0x[start] 0x[end]\n", argv[0]);
      >   } else {
      >     // start and end virtual addresses
      >     uintptr_t sva = (uint32_t)strtol(argv[1], NULL, 0);
      >     uintptr_t eva = (uint32_t)strtol(argv[2], NULL, 0);
      > 
      >     // round to nearest page boundaries
      >     uintptr_t begin = ROUNDDOWN(sva, PGSIZE);
      >     uintptr_t end = ROUNDUP(eva, PGSIZE);
      > 
      >     cprintf("Mappings for [0x%08x, 0x%08x], pages 0x%08x to 0x%08x\n", sva, eva, begin, end);
      > 
      >     while (begin <= end) {
      >       pte_t *pte = pgdir_walk(kern_pgdir, (void *) begin, 1);
      > 
      >       if (!pte) panic("mon_showmappings: Page table entry for 0x%08x resulted in failed allocation in pgdir_walk", begin);
      >       if (!(*pte & PTE_P)) panic("mon_showmappings: Page table entry for 0x%08x not present", begin);
      > 
      >       cprintf("  %08x -> %08x\t", begin, PTE_ADDR(*pte));
      >       
      >       if (*pte & PTE_U) cprintf(" USER");
      >       else cprintf(" KERN");
      > 
      >       if (*pte & PTE_W) cprintf(" READ WRITE");
      >       else cprintf(" READ      ");
      > 
      >       if (*pte & PTE_P) cprintf(" PRESENT");
      >       else cprintf(" NOT_PRESENT");
      > 
      >       cprintf("\n");
      > 
      >       begin += PGSIZE;
      >     }
      >   }
      > 
      >   return 0;
      > }


      > int
      > mon_pageperm(int argc, char **argv, struct Trapframe *tf) {
      >   if (argc != 4 ) {
      >     cprintf("help: %s 0x[address] [P|W|U] [0|1]\n", argv[0]);
      >   } else {
      >     // read in from terminal
      >     uintptr_t addr = (uint32_t)strtol(argv[1], NULL, 0);
      >     char *mode = argv[2];
      >     char *bit = argv[3];
      > 
      >     uint32_t mask = 0;
      >     if (*mode == 'P') {
      >       mask = PTE_P;
      >     } else if (*mode == 'W') {
      >       mask = PTE_W;
      >     } else if (*mode == 'U') {
      >       mask = PTE_U;
      >     }
      > 
      >     cprintf("Setting permission bit for 0x%08x[%c %d] = %c\n", addr, *mode, mask, *bit);
      > 
      > 
      >     pte_t *pte = pgdir_walk(kern_pgdir, (void *) addr, 1);
      > 
      >     if (*bit == '0') {
      >       *pte = *pte & ~mask;
      >     } else if (*bit == '1') {
      >       *pte = *pte | mask;
      >     }
      >   }
      > 
      >   return 0;
      > }


      > int
      > mon_dumpvirt(int argc, char **argv, struct Trapframe *tf) {
      >   if0000000f (argc != 3) {
      >     cprintf("help: %s 0x[start] 0x[end]\n", argv[0]);
      >   } else {
      >     uintptr_t sva = (uint32_t)strtol(argv[1], NULL, 0);
      >     uintptr_t eva = (uint32_t)strtol(argv[2], NULL, 0);
      > 
      >     cprintf("Dumping virtual addresses [0x%08x, 0x%08x]\n", sva, eva);
      > 
      >     for (uintptr_t i = sva; i <= eva; i += sizeof(uint32_t)) {
      >       cprintf("  0x%08x = 0x%08x\n", i, *((uint32_t *) i));
      >     }
      >   }
      > 
      >   return 0;
      > }


      > int
      > mon_dumpphys(int argc, char **argv, struct Trapframe *tf) {
      >   if (argc != 3) {
      >     cprintf("help: %s 0x[start] 0x[end]\n", argv[0]);
      >   } else {
      >     physaddr_t spa = (uint32_t)strtol(argv[1], NULL, 0);
      >     physaddr_t epa = (uint32_t)strtol(argv[2], NULL, 0);
      > 
      >     uintptr_t sva = (uintptr_t) KADDR(spa);
      >     uintptr_t eva = (uintptr_t) KADDR(epa);
      > 
      >     cprintf("Dumping physical addresses [0x%08x, 0x%08x] -> [0x%08x, 0x%08x]\n", spa, epa, sva, eva);
      > 
      >     for (uintptr_t i = sva; i <= eva; i += sizeof(uint32_t)) {
      >       cprintf("  0x%08x (0x%08x) = 0x%08x\n", PADDR((void *) i), i, *((uint32_t *) i));
      >     }
      >   }
      > 
      >   return 0;
      > }


   Testing pageperm and showmappings functions:

      K> pageperm 0xf011a000 W 0
      Setting permission bit for 0xf011a000[W 2] = 0

      K> showmappings 0xf011a000 0xf012a000
      Mappings for [0xf011a000, 0xf012a000], pages 0xf011a000 to 0xf012a000
        f011a000 -> 0011a000        KERN READ       PRESENT
        f011b000 -> 0011b000        KERN READ WRITE PRESENT
        f011c000 -> 0011c000        KERN READ WRITE PRESENT
        ...

      K> pageperm 0xf011a000 W 1   
      Setting permission bit for 0xf011a000[W 2] = 1
      
      K> showmappings 0xf011a000 0xf012a000
      Mappings for [0xf011a000, 0xf012a000], pages 0xf011a000 to 0xf012a000
        f011a000 -> 0011a000        KERN READ WRITE PRESENT
        f011b000 -> 0011b000        KERN READ WRITE PRESENT
        f011c000 -> 0011c000        KERN READ WRITE PRESENT
        ...

      K> pageperm 0xf011b000 U 1    
      Setting permission bit for 0xf011b000[U 4] = 1
      
      K>  showmappings 0xf011a000 0xf012a000
      Mappings for [0xf011a000, 0xf012a000], pages 0xf011a000 to 0xf012a000
        f011a000 -> 0011a000        KERN READ WRITE PRESENT
        f011b000 -> 0011b000        USER READ WRITE PRESENT
        f011c000 -> 0011c000        KERN READ WRITE PRESENT
        ...


   Testing dumpvirt and dumpphys:

      K> dumpvirt 0xf0000000 0xf0000010
      Dumping virtual addresses [0xf0000000, 0xf0000010]
      0xf0000000 = 0xf000ff53
      0xf0000004 = 0xf000ff53
      0xf0000008 = 0xf000e2c3
      0xf000000c = 0xf000ff53
      0xf0000010 = 0xf000ff53

      K> dumpphys 0x0 0x10
      Dumping physical addresses [0x00000000, 0x00000010] -> [0xf0000000, 0xf0000010]
      0x00000000 (0xf0000000) = 0xf000ff53
      0x00000004 (0xf0000004) = 0xf000ff53
      0x00000008 (0xf0000008) = 0xf000e2c3
      0x0000000c (0xf000000c) = 0xf000ff53
      0x00000010 (0xf0000010) = 0xf000ff53